// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"encoding/json"
	"fmt"
	"time"

	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for LessonLessonType.
const (
	Bs LessonLessonType = "bs"
	Ex LessonLessonType = "ex"
	Ls LessonLessonType = "ls"
	Oh LessonLessonType = "oh"
	Sb LessonLessonType = "sb"
)

// Defines values for UserRole.
const (
	UserRoleAdmin   UserRole = "admin"
	UserRoleStudent UserRole = "student"
	UserRoleTeacher UserRole = "teacher"
)

// Defines values for PutViewJSONBodyProvider.
const (
	PutViewJSONBodyProviderCafeteria PutViewJSONBodyProvider = "cafeteria"
	PutViewJSONBodyProviderUntis     PutViewJSONBodyProvider = "untis"
	PutViewJSONBodyProviderWeek      PutViewJSONBodyProvider = "week"
)

// Defines values for PutViewUserUserIdJSONBodyProvider.
const (
	PutViewUserUserIdJSONBodyProviderCafeteria PutViewUserUserIdJSONBodyProvider = "cafeteria"
	PutViewUserUserIdJSONBodyProviderUntis     PutViewUserUserIdJSONBodyProvider = "untis"
	PutViewUserUserIdJSONBodyProviderWeek      PutViewUserUserIdJSONBodyProvider = "week"
)

// Choice Choice of subjects for the classes. {class:[subjects]}
// - If a class has a empty array as a choice all subjects should be shown.
// - If the Class ID is negative it the the choice is a blacklist.
// - If a Class ID is present as a negative as well as a positive value only the positive should be used.
type Choice struct {
	Choice *map[string]interface{} `json:"Choice,omitempty"`
	Id     *int                    `json:"id,omitempty"`
	Name   *string                 `json:"name,omitempty"`
	UserId *int                    `json:"userId,omitempty"`
}

// Class defines model for Class.
type Class struct {
	Id                     *int    `json:"id,omitempty"`
	MainClassLeaderId      *int    `json:"mainClassLeaderId,omitempty"`
	MainTeacherId          *int    `json:"mainTeacherId,omitempty"`
	Name                   *string `json:"name,omitempty"`
	SecondaryClassLeaderId *int    `json:"secondaryClassLeaderId,omitempty"`
	SecondaryTeacherId     *int    `json:"secondaryTeacherId,omitempty"`
}

// Lesson defines model for Lesson.
type Lesson struct {
	AdditionalInformation *string    `json:"additionalInformation,omitempty"`
	BookingText           *string    `json:"bookingText,omitempty"`
	Cancelled             *bool      `json:"cancelled,omitempty"`
	ChairUp               *bool      `json:"chairUp,omitempty"`
	Classes               *[]int     `json:"classes,omitempty"`
	EndTime               time.Time  `json:"endTime"`
	Homework              *string    `json:"homework,omitempty"`
	Id                    *int       `json:"id,omitempty"`
	Irregular             *bool      `json:"irregular,omitempty"`
	LastUpdate            *time.Time `json:"lastUpdate,omitempty"`
	LessonText            *string    `json:"lessonText,omitempty"`

	// LessonType //„ls“ (lesson) | „oh“ (office hour) | „sb“ (standby) | „bs“ (break supervision) | „ex“(examination)  omitted if lesson
	LessonType       LessonLessonType `json:"lessonType"`
	OrigClasses      *[]int           `json:"origClasses,omitempty"`
	OrigRooms        *[]int           `json:"origRooms,omitempty"`
	OrigSubjects     *[]int           `json:"origSubjects,omitempty"`
	OrigTeachers     *[]int           `json:"origTeachers,omitempty"`
	Rooms            *[]int           `json:"rooms,omitempty"`
	StartTime        time.Time        `json:"startTime"`
	Subjects         *[]int           `json:"subjects,omitempty"`
	SubstitutionText *string          `json:"substitutionText,omitempty"`
	Teachers         *[]int           `json:"teachers,omitempty"`
}

// LessonLessonType //„ls“ (lesson) | „oh“ (office hour) | „sb“ (standby) | „bs“ (break supervision) | „ex“(examination)  omitted if lesson
type LessonLessonType string

// Menu defines model for Menu.
type Menu struct {
	Cookteam    *string            `json:"cookteam,omitempty"`
	Date        openapi_types.Date `json:"date"`
	Dessert     *string            `json:"dessert,omitempty"`
	Garnish     *string            `json:"garnish,omitempty"`
	MainDish    *string            `json:"mainDish,omitempty"`
	MainDishVeg *string            `json:"mainDishVeg,omitempty"`
}

// Room defines model for Room.
type Room struct {
	AdditionalInformation *string `json:"additionalInformation,omitempty"`
	Id                    *int    `json:"id,omitempty"`
	Name                  *string `json:"name,omitempty"`
}

// Subject defines model for Subject.
type Subject struct {
	Id        *int    `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	ShortName *string `json:"shortName,omitempty"`
}

// Teacher defines model for Teacher.
type Teacher struct {
	FirstName *string `json:"firstName,omitempty"`
	Id        *int    `json:"id,omitempty"`
	Name      *string `json:"name,omitempty"`
	Pronoun   *string `json:"pronoun,omitempty"`
	ShortName *string `json:"shortName,omitempty"`
	Title     *string `json:"title,omitempty"`
	UserId    *int    `json:"userId,omitempty"`
}

// User defines model for User.
type User struct {
	Classes *[]int `json:"classes,omitempty"`

	// DefaultChoice Choice of subjects for the classes. {class:[subjects]}
	// - If a class has a empty array as a choice all subjects should be shown.
	// - If the Class ID is negative it the the choice is a blacklist.
	// - If a Class ID is present as a negative as well as a positive value only the positive should be used.
	DefaultChoice *Choice   `json:"defaultChoice,omitempty"`
	Email         *string   `json:"email,omitempty"`
	Id            *int      `json:"id,omitempty"`
	Name          string    `json:"name"`
	Role          *UserRole `json:"role,omitempty"`
}

// UserRole defines model for User.Role.
type UserRole string

// UserSettings defines model for UserSettings.
type UserSettings struct {
	// DefaultChoiceID id of default Choice
	DefaultChoiceID *int `json:"defaultChoiceID,omitempty"`

	// Email User email
	Email *string `json:"email,omitempty"`

	// Name User name
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Week Week subtitle for the Week the date(startDate) is in.
type Week = string

// GetCafeteriaParams defines parameters for GetCafeteria.
type GetCafeteriaParams struct {
	Date     *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`
	Duration *int                `form:"duration,omitempty" json:"duration,omitempty"`
}

// PostLoginJSONBody defines parameters for PostLogin.
type PostLoginJSONBody struct {
	// Password yourpassword hashed with SHA256
	Password *string `json:"password,omitempty"`
	Username *string `json:"username,omitempty"`
}

// PutUserUntisAccJSONBody defines parameters for PutUserUntisAcc.
type PutUserUntisAccJSONBody struct {
	Forename *string `json:"forename,omitempty"`
	Surname  *string `json:"surname,omitempty"`
	UntisPWD *string `json:"untisPWD,omitempty"`
	UserName *string `json:"userName,omitempty"`
}

// PostUsersJSONBody defines parameters for PostUsers.
type PostUsersJSONBody struct {
	Password *string `json:"password,omitempty"`
	UserData *User   `json:"userData,omitempty"`
}

// PutViewJSONBody defines parameters for PutView.
type PutViewJSONBody struct {
	Provider []PutViewJSONBodyProvider `json:"provider"`
	Untis    *struct {
		// Choice Choice of subjects for the classes. {class:[subjects]}
		// - If a class has a empty array as a choice all subjects should be shown.
		// - If the Class ID is negative it the the choice is a blacklist.
		// - If a Class ID is present as a negative as well as a positive value only the positive should be used.
		Choice *Choice `json:"Choice,omitempty"`
	} `json:"untis,omitempty"`
}

// PutViewParams defines parameters for PutView.
type PutViewParams struct {
	Date     *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`
	Duration *int                `form:"duration,omitempty" json:"duration,omitempty"`
}

// PutViewJSONBodyProvider defines parameters for PutView.
type PutViewJSONBodyProvider string

// PutViewUserUserIdJSONBody defines parameters for PutViewUserUserId.
type PutViewUserUserIdJSONBody struct {
	Provider []PutViewUserUserIdJSONBodyProvider `json:"provider"`
	Untis    *struct {
		// Choice Choice of subjects for the classes. {class:[subjects]}
		// - If a class has a empty array as a choice all subjects should be shown.
		// - If the Class ID is negative it the the choice is a blacklist.
		// - If a Class ID is present as a negative as well as a positive value only the positive should be used.
		Choice *Choice `json:"Choice,omitempty"`
	} `json:"untis,omitempty"`
}

// PutViewUserUserIdParams defines parameters for PutViewUserUserId.
type PutViewUserUserIdParams struct {
	Date     *openapi_types.Date `form:"date,omitempty" json:"date,omitempty"`
	Duration *int                `form:"duration,omitempty" json:"duration,omitempty"`
}

// PutViewUserUserIdJSONBodyProvider defines parameters for PutViewUserUserId.
type PutViewUserUserIdJSONBodyProvider string

// PostLoginJSONRequestBody defines body for PostLogin for application/json ContentType.
type PostLoginJSONRequestBody PostLoginJSONBody

// PutUserUntisAccJSONRequestBody defines body for PutUserUntisAcc for application/json ContentType.
type PutUserUntisAccJSONRequestBody PutUserUntisAccJSONBody

// PostUsersJSONRequestBody defines body for PostUsers for application/json ContentType.
type PostUsersJSONRequestBody PostUsersJSONBody

// PutUsersUserIdJSONRequestBody defines body for PutUsersUserId for application/json ContentType.
type PutUsersUserIdJSONRequestBody = UserSettings

// PostUsersUserIdChoicesChoiceIdJSONRequestBody defines body for PostUsersUserIdChoicesChoiceId for application/json ContentType.
type PostUsersUserIdChoicesChoiceIdJSONRequestBody = Choice

// PutViewJSONRequestBody defines body for PutView for application/json ContentType.
type PutViewJSONRequestBody PutViewJSONBody

// PutViewUserUserIdJSONRequestBody defines body for PutViewUserUserId for application/json ContentType.
type PutViewUserUserIdJSONRequestBody PutViewUserUserIdJSONBody

// Getter for additional properties for UserSettings. Returns the specified
// element and whether it was found
func (a UserSettings) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UserSettings
func (a *UserSettings) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UserSettings to handle AdditionalProperties
func (a *UserSettings) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["defaultChoiceID"]; found {
		err = json.Unmarshal(raw, &a.DefaultChoiceID)
		if err != nil {
			return fmt.Errorf("error reading 'defaultChoiceID': %w", err)
		}
		delete(object, "defaultChoiceID")
	}

	if raw, found := object["email"]; found {
		err = json.Unmarshal(raw, &a.Email)
		if err != nil {
			return fmt.Errorf("error reading 'email': %w", err)
		}
		delete(object, "email")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UserSettings to handle AdditionalProperties
func (a UserSettings) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DefaultChoiceID != nil {
		object["defaultChoiceID"], err = json.Marshal(a.DefaultChoiceID)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'defaultChoiceID': %w", err)
		}
	}

	if a.Email != nil {
		object["email"], err = json.Marshal(a.Email)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'email': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}
